<pre>
DCP: 0011
æ ‡é¢˜: å°† PoW æ›´æ”¹ä¸º BLAKE3 å’Œ ASERT
ä½œè€…: Dave Collins <davec@decred.org>
çŠ¶æ€: æ´»è·ƒ
åˆ›å»ºæ—¶é—´: 2023-04-13
è®¸å¯è¯: CC0-1.0
è®¸å¯è¯ä»£ç : ISC
æ¡ä»¶: DCP0001, DCP0005, DCP0006, DCP0010
</pre>

==æ¦‚è¿°==

å¯¹ Decred å·¥ä½œé‡è¯æ˜ (PoW) çš„ä¿®æ”¹å¦‚ä¸‹:

* å°†åŒºå—å“ˆå¸Œä¸ PoW å“ˆå¸Œåˆ†å¼€
* åˆ‡æ¢åˆ° <code>BLAKE3</code> çš„ PoW å“ˆå¸Œç®—æ³•
* æ¿€æ´»åé‡ç½®æŒ–çŸ¿æ‰€éœ€çš„ç›®æ ‡éš¾åº¦
* æ›´æ”¹ä¸ºå“åº”é€Ÿåº¦æ›´å¿«çš„éš¾åº¦è°ƒæ•´ç®—æ³• ASERT

==åŠ¨æœº==

è¯¥ææ¡ˆæ˜¯åœ¨DCP0010ä¹‹å‰çš„åŒºå—å¥–åŠ±åˆ†é…å˜æ›´åç»§ç»­åˆ†æçš„ç»“æœï¼Œè¡¨æ˜å¤§éƒ¨åˆ†PoWç®—åŠ›ä»ç„¶é«˜åº¦ä¸­å¿ƒåŒ–ã€‚

ææ¡ˆå¯¹å“ˆå¸Œç®—æ³•æ›´æ”¹ä¸º<code>BLAKE3</code>æ—¨åœ¨æ¶ˆé™¤ä¸Šè¿°é—®é¢˜ï¼Œå¹¶é€šè¿‡æ·˜æ±°ä¸“ç”¨æŒ–çŸ¿ç¡¬ä»¶ï¼ˆASICï¼‰æ¥è¿›ä¸€æ­¥æ”¹å–„å‘è¡Œè¿‡ç¨‹çš„å»ä¸­å¿ƒåŒ–ã€‚

===åŒºå—å“ˆå¸Œä¸ PoW å“ˆå¸Œ===

åŒºå—å“ˆå¸Œç›®å‰å…·æœ‰å¤šç§åŠŸèƒ½ã€‚ä¸è¯¥ææ¡ˆç›¸å…³çš„ä¸€äº›é‡è¦åŠŸèƒ½æ˜¯:

* å®ƒå……å½“æ¯ä¸ªåŒºå—çš„å”¯ä¸€æ ‡è¯†ç¬¦
* å®ƒæäº¤åŒºå—ä¸­çš„æ‰€æœ‰ä¿¡æ¯ä»¥ç¡®ä¿ä¸å˜æ€§
* å®ƒå°†æ¯ä¸ªåŒºå—ä¸å‰ä¸€ä¸ªåŒºå—è”ç³»èµ·æ¥ï¼Œä»è€Œå½¢æˆåŒºå—é“¾
* å®ƒä½œç”¨äºå¼ºåŠ  PoW è¦æ±‚çš„å“ˆå¸Œå€¼

æ›´æ”¹ PoW çš„æ–°å“ˆå¸Œç®—æ³•å¿…ç„¶æ„å‘³ç€å°†ç”Ÿæˆä¸åŒçš„å“ˆå¸Œå€¼ã€‚

é‰´äºæ­¤ï¼Œä½¿ç”¨ä¸åŒçš„å“ˆå¸Œæ›¿åŒºå—å“ˆå¸Œæ¥å¼ºåŠ  PoW è¦æ±‚ï¼Œå…è®¸ç‹¬ç«‹æ›´æ”¹å“ˆå¸Œç®—æ³•ï¼Œè€Œä¸ä¼šå½±å“ä¾èµ–<code>BLAKE-256 r14</code>ç”Ÿæˆçš„åŒºå—å“ˆå¸Œçš„ä»»ä½•å…¶å®ƒåŠŸèƒ½ã€‚

===é‡ç½®ç½‘ç»œç›®æ ‡éš¾åº¦===

å½“å‰æ‰€éœ€çš„ç›®æ ‡éš¾åº¦æ˜¯åŸºäºä¸Šè¿°ä¸“ç”¨ç¡¬ä»¶çš„å­˜åœ¨ï¼Œå› æ­¤åœ¨æ–°çš„å“ˆå¸Œç®—æ³•ä¸‹å¯¹äºéä¸“ç”¨ç¡¬ä»¶æ¥è¯´æ˜æ˜¾å¤ªéš¾äº†ã€‚å› æ­¤ï¼Œåœ¨è½¬å‘æ–°çš„å“ˆå¸Œç®—æ³•æ—¶ï¼Œæ‰€éœ€çš„ç›®æ ‡éš¾åº¦ä¹Ÿéœ€è¦é‡ç½®ä¸ºä½å¾—å¤šçš„åˆå§‹å€¼ã€‚

===éš¾åº¦è°ƒæ•´ç®—æ³•===

PoW çš„ä¸€ä¸ªé‡è¦æ–¹é¢æ˜¯éšç€æŒ–çŸ¿ç®—åŠ›çš„å˜åŒ–ä¿æŒç›®æ ‡å¹³å‡åŒºå—æ—¶é—´ã€‚è¿™æ˜¯é€šè¿‡éš¾åº¦è°ƒæ•´ç®—æ³• (DAA) åŠ¨æ€æ”¹å˜æ‰€éœ€éš¾åº¦æ¥å®ç°çš„ã€‚

Decred è‡ªæ¨å‡ºä»¥æ¥ä½¿ç”¨çš„ç®—æ³•åŸºäºæŒ‡æ•°ç§»åŠ¨å¹³å‡çº¿ (EMA)ï¼Œå¹¶ä¸”åœ¨ç»´æŒç›®æ ‡åŒºå—æ—¶é—´æ–¹é¢åšå¾—ç›¸å½“å¥½ã€‚å…·ä½“è€Œè¨€ï¼Œåœ¨æˆªè‡³æ’°å†™æœ¬æ–‡æ—¶è¶…è¿‡ 7 å¹´çš„è¿è¡Œä¸­ï¼Œä¸»ç½‘çš„å¹³å‡å‡ºå—æ—¶é—´ä¸ºé¢„æœŸçš„å¹³å‡æ—¶é—´ 5 åˆ†é’Ÿï¼Œè€Œç½‘ç»œä»…æ¯”å®Œç¾çš„ç†æƒ³è®¡åˆ’æ™šäº†çº¦ 8.5 å°æ—¶ã€‚

ç„¶è€Œï¼Œåœ¨æ­¤ææ¡ˆä¹‹å‰çš„ DAA ä»…æ¯éš”ä¸€æ®µæ—¶é—´æ›´æ–°ä¸€æ¬¡ç›®æ ‡éš¾åº¦ï¼ˆä¸»ç½‘ç»œä¸Šçš„ 144 ä¸ªåŒºå—ï¼‰ï¼Œå› æ­¤å½“ç½‘ç»œä¸»è¦ç”± GPUï¼ˆè€Œä¸æ˜¯ ASICï¼‰æŒ–çŸ¿æ—¶ï¼Œå®ƒä¼šç¨å¾®å®¹æ˜“å—åˆ°ä¸€äº›ä¸è‰¯è¡Œä¸ºçš„å½±å“ã€‚

æœ€ç°å®çš„æ¡ˆä¾‹ä¹‹ä¸€ä¸â€œè‚‡äº‹é€ƒé€¸â€æŒ–çŸ¿æœ‰å…³ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå®ƒæ¶‰åŠçŸ¿å·¥åˆ©ç”¨ä¸åŒåŒºå—é“¾å®æ–½çš„å„ç§ DAA çš„å¼±ç‚¹ï¼Œé€šè¿‡ä¸æ–­åœ°åœ¨å—å½±å“çš„åŒºå—é“¾ä¹‹é—´åˆ‡æ¢ç®—åŠ›ï¼Œä»¥è·å¾—æ¯”ç¨³å®šæŒ–çŸ¿æ›´é«˜çš„ç›ˆåˆ©èƒ½åŠ›ã€‚ç”±äºå®ƒé€šå¸¸å¾ˆæœ‰æ•ˆï¼Œå› æ­¤è®¸å¤šæµè¡Œçš„ç°ä»£æŒ–çŸ¿è½¯ä»¶ä¼šè‡ªåŠ¨å°è¯•åˆ©ç”¨è¯¥æŠ€æœ¯æ¥æœ€å¤§åŒ–ç›ˆåˆ©èƒ½åŠ›ã€‚åè¿‡æ¥ï¼Œè¿™ç§è¡Œä¸ºå¯èƒ½ä¼šå¯¼è‡´å—å½±å“åŒºå—é“¾çš„å“ˆå¸Œç®—åŠ›å‡ºç°æå¤§çš„æ³¢åŠ¨ã€‚ï¼ˆç±»ä¼¼äºæœºæªæ± ï¼‰

è¯¥è¡Œä¸ºå¯èƒ½å¯¼è‡´å¯¹æ•´ä¸ªç½‘ç»œé€ æˆæœ‰å®³çš„åæœï¼Œä¾‹å¦‚ï¼š

* å»¶é•¿äº¤æ˜“ç¡®è®¤æ—¶é—´
* ç»´æŒç½‘ç»œè¿è¡Œçš„å…¶ä½™ç¨³å®šçŸ¿å·¥çš„ç›ˆåˆ©èƒ½åŠ›ä¸‹é™
* é›ªçƒæ•ˆåº”ä½¿å‰©ä¸‹çš„ç¨³å®šçŸ¿å·¥è¦ä¹ˆè¢«è¿«æ•ˆä»¿ï¼Œè¦ä¹ˆå®Œå…¨åœæ­¢æŒ–çŸ¿ï¼Œè¿›ä¸€æ­¥åŠ å‰§äº†æƒ…å†µ

ææ¡ˆä¸­çš„ ASERT DAA é€šè¿‡æé«˜å“åº”èƒ½åŠ›å¹¶é¿å…å…¶ä»–ä¸€äº›æ¬¡è¦è¾¹ç¼˜æ¡ä»¶ï¼ˆä¾‹å¦‚çŸ¿å·¥å¯èƒ½è¯•å›¾åˆ©ç”¨é”™è¯¯ç´¯ç§¯å’Œå‰Šæ³¢æ¥è·å¾—ä¸å…¬å¹³ä¼˜åŠ¿ï¼‰æ¥è¿›ä¸€æ­¥å¼ºåŒ–ç½‘ç»œï¼Œä»¥é˜²æ­¢æ­¤ç±»ä¸è‰¯è¡Œä¸ºã€‚ä¸ EMA DAA ç›¸æ¯”ï¼Œè¯¥ç®—æ³•è¿˜å…·æœ‰å®ç°æ›´ç®€å•ã€è®¡ç®—æ›´é«˜æ•ˆçš„ä¼˜ç‚¹ã€‚

æœ€åï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒDecred çš„ EMA DAA æ˜¯ ASERT ç®—æ³•çš„ç›¸å¯¹ç‰ˆæœ¬çš„è¿‘ä¼¼ã€‚æ¢å¥è¯è¯´ï¼Œè¯¥ç®—æ³•æ˜¯å…·æœ‰ç»è¿‡éªŒè¯çš„å¾®æ”¹è¿›ç‰ˆæœ¬ã€‚

==è§„æ ¼==

===æ•´æ•°æ•°å­¦===

ä¸ºäº†ä¿ƒè¿›è·¨å®ç°å’Œè¯­è¨€çš„æ›´å¥½å…¼å®¹æ€§ï¼Œæœ¬è§„èŒƒå®šä¹‰çš„å„ç§å…¬å¼ä½¿ç”¨æ•´æ•°æ•°å­¦è€Œä¸æ˜¯æµ®ç‚¹æ•°å­¦ï¼Œå¦‚ä½¿ç”¨æˆªæ–­æ•´æ•°éƒ¨åˆ† (Int) å’Œä¸‹é™<ref>[[https://en.wikipedia.org/wiki/Floor_and_ceiling_functions|Wikipedia: Floor and ceiling functions]]</ref>å‡½æ•°æ‰€ç¤º ã€‚è¿™å¯¹äºå…±è¯†ä»£ç æ¥è¯´æ˜¯éå¸¸ç†æƒ³çš„ï¼Œå› ä¸ºç”±äºèˆå…¥é”™è¯¯å’Œå„è‡ªåº“ä¸­çš„ä¸ç¡®å®šæ€§ç­‰é—®é¢˜ï¼Œæµ®ç‚¹æ•°å­¦å¯èƒ½ä¼šåœ¨ä¸åŒè¯­è¨€ä¹‹é—´å‡ºç°é—®é¢˜ã€‚

===å·¥ä½œé‡è¯æ˜å“ˆå¸Œ===

ä»æœ¬è§„èŒƒå¼€å§‹ï¼Œå¿…é¡»å¼•å…¥ä¸åŒºå—å“ˆå¸Œä¸åŒçš„æ–° PoW å“ˆå¸Œï¼Œå¹¶ä¸”åŒºå—å“ˆå¸Œå¿…é¡»ä¿æŒä¸æœ¬è§„èŒƒä¹‹å‰çš„ç›¸åŒã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒåŒºå—å“ˆå¸Œå¿…é¡»ä½¿ç”¨<code>BLAKE-256 r14</code>ç»§ç»­æäº¤åˆ°åŒºå—å¤´å­—æ®µã€‚

æ–°çš„ PoW å“ˆå¸Œè¿˜å¿…é¡»ä½¿ç”¨ä¸<code>BLAKE3</code>åŒºå—å“ˆå¸Œå®Œå…¨ç›¸åŒçš„åŒºå—å¤´æ•°æ®åºåˆ—åŒ–æ¥æäº¤åŒºå—å¤´çš„æ‰€æœ‰å­—æ®µã€‚

æ­¤å¤–ï¼Œé™¤äº† [[#proof-of-work-enforcement|PoW æ‰§è¡Œ]]éƒ¨åˆ†ä¸­æ˜ç¡®è¯¦ç»†è¯´æ˜çš„ä¿®æ”¹ä¹‹å¤–ï¼Œæ‰€æœ‰æ¶‰åŠåŒºå—å“ˆå¸Œçš„å…±è¯†è§„åˆ™éƒ½å¿…é¡»ä¿ç•™ã€‚

ä¸¤ä¸ªå“ˆå¸Œå€¼çš„åºåˆ—åŒ–æ•°æ®å¦‚ä¸‹ï¼š

<img src="block_header_serialization.svg" width="100%" height="341" />

{|
!ä»é›¶å¼€å§‹çš„ç¼“å†²åŒºåç§»!!å­—èŠ‚æ•°!!åç§°!!æ•°æ®ç±»å‹!!è®°å½•
|-
|0||4||Block Version||int32||Little endian.
|-
|4||32||Previous Block Header Hash||[32]byte
|Internal byte order.  The <code>BLAKE-256</code> hash of the previous block
header.  This is '''NOT''' the <code>BLAKE3</code> PoW hash this specification
introduces.
|-
|36||32||Merkle Root Hash||[32]byte
|Internal byte order.  At the time of this specification, this is the
[[../dcp-0005/dcp-0005.mediawiki#combined-transaction-tree-merkle-root|combined transaction tree merkle root]]
as defined in DCP0005.
|-
|68||32||Commitment Root Hash||[32]byte
|Internal byte order.  At the time of this specification, this is the
[[../dcp-0005/dcp-0005.mediawiki#version-1-block-header-commitment|version 1 block header commitment root hash]]
as defined in DCP0005.
|-
|100||2||Vote Bits||uint16||Little endian.
|-
|102||6||Final State||[6]byte||Internal byte order.
|-
|108||2||Num Voters||uint16||Little endian.
|-
|110||1||Fresh Stake||uint8||
|-
|111||1||Num Revocations||uint8||
|-
|112||4||Pool Size||uint32||Little endian.
|-
|116||4||Difficulty Bits||uint32
|Little endian.
[[#difficulty-bits-format|Difficulty Bits Format]].
|-
|120||8||Stake Difficulty||int64||Little endian.  At the time of this
specification, this is the result of the
[[../dcp-0001/dcp-0001.mediawiki#stake-difficulty-formulas|stake difficulty formulas]]
as defined in DCP0001.
|-
|128||4||Block Height||uint32||Little endian.
|-
|132||4||Block Size||uint32||Little endian.
|-
|136||4||Block Timestamp||uint32||Little endian.
|-
|140||36||Extra Data||[36]byte
|Internal byte order.  Implementations MUST treat this field as a binary blob
and serialize it unaltered.
<br /><br />
Note that it is common for implementations to define separate fields with their
internal block header data structures that split this space up in order to
facilitate the mining process.
<br /><br />
For example, for legacy reasons, the first 4 bytes are often a separate
<code>Nonce</code> field treated as a little-endian uint32 in the data
structures with the remaining 32 bytes denominated as the <code>ExtraData</code>
field.
<br /><br />
Miners and pools may allocate this space in whatever manner is the most
efficient for them.  However, it is '''HIGHLY''' recommended to use the first 8
bytes as the nonce for each individual miner, the next 4 bytes for the pool
nonce, and set the remaining bytes to all zero.
<br /><br />
This recommendation allows pools to support up to 2<sup>32</sup> devices each
capable of hash rates up to around 18.4 EH/s (18.4x10<sup>18</sup> hashes/sec).
|-
|176||4||Stake Version||uint32||Little endian
|}

===æ¯”ç‰¹éš¾åº¦æ ¼å¼===

å½“åœ¨æ¯ä¸ªæ ‡å¤´çš„éš¾åº¦ä½å­—æ®µä¸­æŒ‡å®šæ—¶ï¼Œç›®æ ‡éš¾åº¦é˜ˆå€¼å¿…é¡»ä¿ç•™ç°æœ‰çš„æ¯”ç‰¹éš¾åº¦æ ¼å¼ã€‚

æ¯”ç‰¹éš¾åº¦æ ¼å¼æ˜¯ç”¨æ— ç¬¦å· 32 ä½æ•´æ•°è¡¨ç¤ºç›®æ ‡éš¾åº¦çš„æœ€é«˜æœ‰æ•ˆä½ã€‚è¯¥è¡¨ç¤ºæ³•ç±»ä¼¼äº IEEE754 æµ®ç‚¹<ref>[[https://en.wikipedia.org/wiki/IEEE_754|Wikipedia: IEEE754]]</ref>ã€‚

ä¸ IEEE754 æµ®ç‚¹ä¸€æ ·ï¼Œä¹Ÿæœ‰ä¸‰ä¸ªåŸºæœ¬ç»„æˆéƒ¨åˆ†ï¼šç¬¦å·ã€æŒ‡æ•°å’Œå°¾æ•°ï¼ˆä¹Ÿç§°ä¸ºæœ‰æ•ˆæ•°ï¼‰ã€‚å®ƒä»¬æŒ‰ç…§ä»¥ä¸‹å›¾è¡¨å’Œè§„æ ¼è¿›è¡Œç»†åˆ†ï¼š

<!--E(T) = \begin{cases}0 & \text{if } T = 0 \\2^{24}\cdot exponent + mantissa & \text{if } T \gt 0 \\2^{24}\cdot exponent + 2^{23} + mantissa & \text{if } T \lt 0\end{cases}-->
<!--exponent = \left\lfloor log_{256}(2 \cdot |T|) \right\rfloor + 1-->
<!--mantissa = \left\lfloor |T| \cdot 256^{3-exponent} \right\rfloor-->
<!--T = (-1)^{sign} \cdot \left\lfloor mantissa \cdot 256^{exponent - 3} \right\rfloor-->
<img src="difficulty_bits_breakdown.svg" width="100%" height="534" />

{|
!æ¯”ç‰¹éš¾åº¦!!æè¿°
|-
|0-22|||Mantissa (Significand).  The most significant bits.  A bitmask of
0x007fffff may be applied to extract this value.
|-
|23||Sign bit.  The encoded value MUST be interpreted as negative when this bit
is set.
|-
|24-31||Exponent.  The base 256 exponent plus 3.
|}

====å®æ–½è­¦å‘Š====

æä¾›çš„ç¼–ç å…¬å¼ç²¾ç¡®åœ°æŒ‡å®šäº†æ‰€éœ€çš„è®¡ç®—ï¼Œä½†æ˜¯ï¼Œç”±äºå®ç°å¯¹æ•°åº“ä¸­çš„èˆå…¥è¯¯å·®å’Œç²¾åº¦é™åˆ¶ï¼Œå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€åœ¨ç›´æ¥å®ç°å…¬å¼æ—¶ä¸ä¼šä¸ºæ‰€æœ‰å€¼ç”Ÿæˆæ­£ç¡®çš„ç»“æœ<sup>[ [[#typical-logarithm-precision-limitations|è¯¦ç»†ä¿¡æ¯]] ]</sup>ã€‚

å› æ­¤ï¼Œå¼ºçƒˆå»ºè®®ä½¿ç”¨å…¶ä½™éƒ¨åˆ†æ¦‚è¿°çš„ç®—æ³•æ¥æ‰§è¡Œç¼–ç å’Œè§£ç ï¼Œè€Œä¸æ˜¯å°è¯•ç›´æ¥å®ç°å…¬å¼ã€‚æä¾›çš„ç®—æ³•é€šè¿‡æ•´æ•°æ•°å­¦ã€æ¨¡ç®—æœ¯ã€ä½ç§»ä½å’Œä½æ©ç çš„ç»„åˆæ¥å®ç°å…¬å¼ï¼Œæ‰€æœ‰è¿™äº›éƒ½ä¼šäº§ç”Ÿç²¾ç¡®çš„ç»“æœå¹¶ä¸”å…·æœ‰é«˜åº¦å¯ç§»æ¤æ€§ã€‚

====ç²¾åº¦è€ƒè™‘å› ç´ ====

ä»¥ä¸‹ç®—æ³•ä¾èµ–äºä»»æ„ç²¾åº¦æ•´æ•°ï¼Œä»¥æ”¯æŒå¯¹å¯ç¼–ç çš„å…¨éƒ¨å¯èƒ½å€¼è¿›è¡Œè§£ç ã€‚

ç„¶è€Œï¼Œå®é™…ä¸Šï¼ŒDecred ä¸­çš„æ‰€æœ‰ç›®æ ‡å›°éš¾éƒ½å¼ºåˆ¶ä¸ºæ— ç¬¦å· 256 ä½æ•´æ•°ã€‚

å› æ­¤ï¼Œå®ç°å¯ä»¥é€‰æ‹©ä½¿ç”¨æ— ç¬¦å· 256 ä½æ•´æ•°ï¼Œåªè¦å®ƒä»¬åœ¨è§£ç æ—¶æ­£ç¡®æ£€æµ‹å¹¶æ‹’ç»è´Ÿæ•°æˆ–å¤§äº 2<sup>256</sup> - 1ï¼ˆæ— ç¬¦å· 256 ä½æ•´æ•°å¯è¡¨ç¤ºçš„æœ€å¤§å€¼ï¼‰çš„ç¼–ç å€¼ã€‚

====è§£ç ç®—æ³•====

ä»¥ä¸‹ç®—æ³•å°†ä½¿ç”¨å°¾æ•°å’ŒæŒ‡æ•° çš„ä¸­é—´å˜é‡<code>T</code>ä»éš¾åº¦ä½è§£ç ç›®æ ‡éš¾åº¦ï¼š<code>c</code><code>m</code><code>x</code> 

# è®¾ç½®<code>m = c (mod 2^23)</code>ä¸ºæœ€ä½æœ‰æ•ˆ 23 ä½<code>c</code>
#: å®ç°å¯ä»¥é€šè¿‡ä½¿ç”¨ä½æ©ç æ¥ä¼˜åŒ–å®ƒï¼š<code>m = c & 0x007fffff</code>
# è®¾ç½®<code>x = floor(c / 2^24)</code>ä¸ºæœ€é«˜æœ‰æ•ˆ 8 ä½<code>c</code>
#: å®ç°å¯ä»¥é€šè¿‡ä½¿ç”¨å³ä½ç§»ä½æ¥ä¼˜åŒ–è¿™ä¸€ç‚¹ï¼š<code>x = c >> 24</code>
# å¦‚æœ<code>x â‰¤ 3</code> åˆ™è®¾ç½®<code>T = m / 256^(3 - x)</code>å¦åˆ™è®¾ç½®<code>T = m * 256^(x - 3)</code>
#: å®ç°å¯ä»¥<code>x â‰¤ 3</code>é€šè¿‡ä½¿ç”¨å³ä½ç§»ä½æ¥ä¼˜åŒ–æƒ…å†µï¼š<code>T = m >> (8 * (3-x))</code>ä»¥åŠ<code>x > 3</code>é€šè¿‡ä½¿ç”¨å·¦ä½ç§»ä½æ¥ä¼˜åŒ–æƒ…å†µï¼š <code>T = m << (8 * (x-3))</code>
#: æ³¨æ„ï¼šEnsure <code>T</code>èƒ½å¤Ÿå¤„ç†æœ€å¤§æ”¯æŒçš„å¯è§£ç å€¼çš„å¤§æ•´æ•°ï¼ˆæ”¯æŒæ•´ä¸ªèŒƒå›´æ—¶ä¸ºÂ± 8,388,607 x 2<sup>2016</sup> ï¼Œå¦‚æœä»…æ”¯æŒæ— ç¬¦å· 256 ä½æ•´æ•°åˆ™ä¸º2<sup>256</sup> - 1ï¼‰
# <code>c</code>å¦‚æœè®¾ç½®äº†ä½ 23åˆ™è¿”å›<code>-T</codeï¼Œå¦åˆ™è¿”å›<code>T</code>

====ç¼–ç ç®—æ³•====

ä»¥ä¸‹ç®—æ³•å°†ä½¿ç”¨å°¾æ•°å’ŒæŒ‡æ•°çš„ ä¸­é—´å˜é‡å°†ç›®æ ‡éš¾åº¦ç¼–ç <code>T</code>ä¸ºéš¾åº¦ä½ï¼š<code>c</code><code>m</code><code>x</code> 


# OPTIONAL:Assert <code>T â‰¥ 0</code> å’Œ <code>T â‰¤ 2^256 - 1</code>
#: å®ç°å¯ä»¥é€‰æ‹©æ–­è¨€è¾“å…¥å€¼æ˜¯éè´Ÿçš„ï¼Œå¹¶ä¸”å°äºæˆ–ç­‰äºæ— ç¬¦å· 256 ä½æ•´æ•°è¡¨ç¤ºçš„æœ€å¤§å€¼ï¼Œå› ä¸ºè¶…å‡ºè¯¥èŒƒå›´çš„ç›®æ ‡éš¾åº¦åœ¨ Decred ä¸­æ˜¯æ— æ•ˆçš„
# å¦‚æœ <code>T = 0</code> åˆ™è¿”å› <code>0</code>
# è®¾ç½® <code>b = bitlen(T)</code> å…¶ä¸­ <code>bitlen</code> æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›è¡¨ç¤ºäºŒè¿›åˆ¶å€¼æ‰€éœ€çš„ä½æ•°
# è®¾ç½® <code>x = floor((b + 7) / 8)</code>
# å¦‚æœ <code>x â‰¤ 3</code> åˆ™è®¾ç½® <code>m = abs(T) * 256^(3 - x)</code> å¦åˆ™è®¾ç½® <code>m = floor(abs(T) / 256^(x - 3))</code>
#: å¦‚æœå®ç°äº†æ–­è¨€è¾“å…¥å€¼éè´Ÿçš„å¯é€‰ç¬¬ä¸€æ­¥ï¼Œåˆ™å®ç°å¯ä»¥çœç•¥å–ç»å¯¹å€¼
#: å®ç°å¯ä»¥ <code>x â‰¤ 3</code> é€šè¿‡ä½¿ç”¨å·¦ä½ç§»ä½æ¥ä¼˜åŒ–æƒ…å†µï¼š <code>m = abs(T) << (8 * (3-x))</code> ä»¥åŠ <code>x > 3</code> é€šè¿‡ä½¿ç”¨å³ä½ç§»ä½æ¥ä¼˜åŒ–æƒ…å†µï¼š <code>m = abs(T) >> (8 * (x-3))</code>
#  <code>m</code> å¦‚æœè®¾ç½®äº†ä½ 23 åˆ™è®¾ç½® <code>m = floor(m / 256)</code> å¹¶è®¾ç½® <code>x = x + 1</code>
#: å®ç°å¯ä»¥é€šè¿‡ä½¿ç”¨å³ä½ç§»ä½æ¥ä¼˜åŒ–è¿™ä¸€ç‚¹ï¼š <code>m = m >> 8</code>
# è®¾ç½® <code>c = (x * 2^24) + m</code>
#: å®ç°å¯ä»¥é€šè¿‡ä½¿ç”¨å·¦ç§»ä½å’ŒæŒ‰ä½æˆ–æ¥ä¼˜åŒ–è¿™ä¸€ç‚¹ï¼š <code>c = (x << 24) | m</code>
# å¦‚æœ <code>T < 0</code> åˆ™è®¾ç½® <code>c = c + 2^23</code> è®¾ç½®ç¬¦å·ä½
#: å¦‚æœå®ç°äº†æ–­è¨€è¾“å…¥å€¼éè´Ÿçš„å¯é€‰ç¬¬ä¸€æ­¥ï¼Œåˆ™å®ç°å¯ä»¥çœç•¥æ­¤æ­¥éª¤
#: å®ç°å¯ä»¥é€šè¿‡ä½¿ç”¨ä½æ©ç çš„æŒ‰ä½æˆ–æ¥ä¼˜åŒ–è¿™ä¸€ç‚¹ï¼š <code>c = c | 0x00800000</code>
# è¿”å› <code>c</code>

===ASERTéš¾åº¦è°ƒæ•´ç®—æ³•===

è¯¥è§„èŒƒæå‡ºäº†ä¸€ç§æ–°çš„éš¾åº¦è°ƒæ•´ç®—æ³•ï¼ˆDAAï¼‰ï¼Œåä¸º ASERTï¼ˆç»å¯¹è°ƒåº¦æŒ‡æ•°ä¸Šå‡ç›®æ ‡ï¼‰ã€‚

====ASERT éš¾åº¦è®¡ç®—é—´éš”====

å¿…é¡»ä½¿ç”¨æ–°çš„ ASERT ç®—æ³•è®¡ç®—æ¯ä¸ªå—æ‰€éœ€çš„ç›®æ ‡éš¾åº¦ã€‚

è¯·æ³¨æ„ï¼Œæ¯ä¸ªå—çš„è®¡ç®—è¦æ±‚ä¸ DAA åœ¨æœ¬è§„èŒƒä¹‹å‰å¼ºåˆ¶æ‰§è¡Œçš„å®šæœŸè®¡ç®—è¦æ±‚ä¸åŒã€‚


====ASERT é”šå®šå—====

æ‰€æœ‰ç›®æ ‡éš¾åº¦è®¡ç®—å¿…é¡»ç›¸å¯¹äºå¦‚ä¸‹ç¡®å®šçš„é”šå®šå—æ¥æ‰§è¡Œï¼š

* å¯¹äºä¸»ç½‘å’Œæµ‹è¯•ç½‘ç‰ˆæœ¬3ï¼š
** é”šå®šå®šåŒºå—å¿…é¡»è®¾ç½®ä¸ºæ–°è§„åˆ™ç”Ÿæ•ˆåŒºå—ä¹‹å‰çš„ä¸€ä¸ªåŒºå—
* å¯¹äºä»ä¸€å¼€å§‹å°±ä½¿ç”¨æ‰€æå‡ºçš„ç®—æ³•çš„å…¶å®ƒç½‘ç»œï¼š
** é”šå®šå—ä¸€æ—¦è¢«å¼€é‡‡å°±å¿…é¡»è®¾ç½®ä¸ºå— 1
** åŒºå— 1 çš„ç›®æ ‡éš¾åº¦å¿…é¡»è®¾ç½®ä¸ºç½‘ç»œçš„åˆå§‹éš¾åº¦

æ›´æ–°ï¼š

ç°è¯¥ææ¡ˆåœ¨ä¸»ç½‘å’Œæµ‹è¯•ç½‘ç¬¬3ç‰ˆçš„è®®ç¨‹æŠ•ç¥¨å‡å·²é€šè¿‡ï¼Œæ–°è§„åˆ™å·²ç”Ÿæ•ˆï¼Œå…¶å…·ä½“é”šå®šåŒºå—å·²ç¡®å®šå¦‚ä¸‹ï¼š

{|
!ç½‘ç»œ!!åŒºå—å“ˆå¸Œ!!åŒºå—é«˜åº¦
|-
|ä¸»ç½‘||0000000000000000c293d8c67409d05e960447ea25cdaf770e864d995c764ef0||794367
|-
|æµ‹è¯•ç½‘ç‰ˆæœ¬ 3||000000b396bfeaa6ae6fa9e3cee441d7215191630bdaa9b979a872985caed727||1170047
|}

ä¸ºäº†ç®€å•èµ·è§ï¼Œå®ç°å¯ä»¥å¯¹è¿™äº›å€¼è¿›è¡Œç¡¬ç¼–ç ã€‚

====ASERTéš¾åº¦è®¡ç®—å…¬å¼====

<!--
T_{N} = \mathrm{min}\left(\mathrm{max}\left(\left\lfloor T_{s} \cdot F \cdot 2^{n-16}\right\rfloor, 1\right), T_{ub}\right)
x = \rm{Int}\left(\frac{2^{16}(\Delta t - \Delta h \cdot I_{b})}{\tau}\right)
n = \left\lfloor\frac{x}{2^{16}}\right\rfloor
f = x\bmod{2^{16}}
F = 2^{16} + \left\lfloor\frac{195766423245049f + 971821376f^{2} +5127f^{3} + 2^{47}}{2^{48}}\right\rfloor
-->
<img src="asert.svg" width="100%" height="379" />

æœ¯è¯­è§£é‡Šï¼š

T<sub>N</sub> = ç»™å®šé«˜åº¦ä¸‹çš„ç›®æ ‡éš¾åº¦ N<br />
T<sub>s</sub> = åˆå§‹å¯åŠ¨éš¾åº¦<br />
Î”t = æœ€è¿‘åŒºå—ä¸é”šå®šå—ä¹‹é—´çš„æ—¶é—´å¢é‡ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰<br />
Î”h = æœ€è¿‘åŒºå—ä¸é”šå®šå—ä¹‹é—´çš„é«˜åº¦å¢é‡<br />
I<sub>b</sub> = ç›®æ ‡å—é—´éš”ä»¥ç§’ä¸ºå•ä½<br />
T<sub>ub</sub> = æœ€ç»ˆè®¡ç®—ç›®æ ‡éš¾åº¦çš„ä¸Šé™ï¼ˆå·¥ä½œé‡è¯æ˜é™åˆ¶ï¼‰<br />
ğœ = åŠè¡°æœŸä»¥ç§’ä¸ºå•ä½

å¿…é¡»ä½¿ç”¨ä»¥ä¸‹æ¯ä¸ªç½‘ç»œå€¼è¿›è¡Œè®¡ç®—ï¼š

{|
!èŒƒå›´!!ä¸»ç½‘å€¼!!æµ‹è¯•ç½‘ (ç‰ˆæœ¬ 3) å€¼
|-
|T<sub>s</sub>||42,406 x 2<sup>192</sup>||65,535 x 2<sup>216</sup>
|-
|I<sub>b</sub>||300||120
|-
|T<sub>ub</sub>||2<sup>224</sup> - 1||2<sup>232</sup> - 1
|-
|ğœ||43,200||720
|}

é‡è¦çš„å®æ–½æ³¨æ„äº‹é¡¹ï¼š

*  ç”±äºé”šå®šå—é€‰æ‹©æ‰€æ–½åŠ çš„é™åˆ¶ï¼Œè´Ÿé«˜åº¦å¢é‡(<code>Î”h</code>)åœ¨æ­£ç¡®çš„å®ç°ä¸­æ˜¯ä¸å¯èƒ½çš„
** å®ç°å¯ä»¥ä¸ºæ­¤å‰ææ¡ä»¶æ·»åŠ æ–­è¨€
* <code>Int</code> è®¡ç®—æŒ‡æ•°æ—¶ä½¿ç”¨çš„å‡½æ•° (<code>x</code>)è¡¨ç¤ºå€¼çš„æ•´æ•°éƒ¨åˆ†ï¼Œè¿™æ„å‘³ç€å‘ 0 æˆª 
** è¯·æ³¨æ„ï¼Œè¿™ä¸ä¸‹å–æ•´å‡½æ•°ä¸åŒï¼Œä¸‹å–æ•´å‡½æ•°å°†è´Ÿå€¼æˆªæ–­ä¸ºè´Ÿæ— ç©·å¤§
** å®ç°å¿…é¡»ç¡®ä¿æ­¤è®¡ç®—æˆªæ–­ä¸º 0
* æŒ‡æ•° (<code>f</code>)çš„å°æ•°éƒ¨åˆ†  (<code>x</code>)  é¢„è®¡ä¼šæ ‡å‡†åŒ–ä¸ºèŒƒå›´ [0,2<sup>16</sup> )ï¼Œè¿™æ˜¯æ¨¡è¿ç®—ç¬¦çš„æ ‡å‡†è¡Œä¸º
** å®ç°å¯ä»¥é€šè¿‡ä½¿ç”¨æ©ç  0xffff æ‰§è¡ŒæŒ‰ä½ AND æ¥ä¼˜åŒ–è®¡ç®—
* æŒ‡æ•° (<code>n</code>) çš„æ•´æ•°éƒ¨åˆ† (<code>x</code>) æ˜¯å‘ä¸‹é™¤æ³•ï¼Œå¯¹äºè´Ÿå€¼ä¼šå‘è´Ÿæ— ç©·å¤§æˆªæ–­
** å®ç°å¯ä»¥é€šè¿‡ä½¿ç”¨ç®—æœ¯<ref>[[https://en.wikipedia.org/wiki/Arithmetic_shift|Wikipedia: Arithmetic shift]]</ref>å³ç§» 16 æ¥ä¼˜åŒ–è®¡ç®—
*** è­¦å‘Š: æ­¤è®¡ç®—çš„é€»è¾‘<ref>[[https://en.wikipedia.org/wiki/Logical_shift|Wikipedia: Logical shift]]</ref>å³ç§»ä¸ä¼šä¸ºæ‰€æœ‰è¾“å…¥äº§ç”Ÿæ­£ç¡®çš„ç»“æœ
* å¯¹äºåˆ†æ•°å› å­çš„è®¡ç®—<code>F</code>:
** ç”±äºèŒƒå›´çš„ç¼˜æ•…ï¼Œåœ°æ¿å†…çš„åˆ†å­ä¿è¯ä¸ºæ­£å€¼<code>f</code>
** åœ°æ¿å†…éƒ¨çš„åˆ†å­éœ€è¦å…¨64ä½ä»¥é¿å…æº¢å‡º
** å®ç°å¯ä»¥é€šè¿‡ä½¿ç”¨å³ç§» 48 æ¥ä¼˜åŒ–åœ°æ¿é™¤æ³• 2 <sup>48</sup> 
** æ€»ä½“ç»“æœä¿è¯æœ€å¤§ä¸º 17 ä½
*å®ç°å¯ä»¥é€šè¿‡åœ¨ n â‰¥ 16 æ—¶ä½¿ç”¨å·¦ç§» n-16 æˆ–åœ¨ n < 16 æ—¶å³ç§» 16-n æ¥ä¼˜åŒ–æœ€ç»ˆä¸‹åº•ç›®æ ‡éš¾åº¦è®¡ç®—ä¸­çš„ä¹˜æ³• 2<sup>n-16</sup> 

===å·¥ä½œé‡è¯æ˜æ‰§è¡Œ===

æœ¬èŠ‚ä½¿ç”¨æœ¯è¯­'''ç›®æ ‡éš¾åº¦'''æ¥æŒ‡ä»£å…·ä½“çš„æ•°å€¼ï¼Œä½¿ç”¨'''éš¾åº¦ä½'''æ¥æŒ‡ä»£ ç›®æ ‡éš¾åº¦çš„[[#difficulty-bits-format|ç¼–ç ç´§å‡‘å½¢å¼]]ã€‚

å¿…é¡»æ‰§è¡Œä»¥ä¸‹éš¾åº¦è§„åˆ™ï¼š

* é€šè¿‡è§£ç å—å¤´ä¸­çš„éš¾åº¦ä½è·å¾—çš„ç›®æ ‡éš¾åº¦å¿…é¡»å¤§äºé›¶
* é€šè¿‡è§£ç å—å¤´ä¸­çš„éš¾åº¦ä½è·å¾—çš„ç›®æ ‡éš¾åº¦å¿…é¡»å°äºæˆ–ç­‰äºæ´»åŠ¨ç½‘ç»œçš„å·¥ä½œé‡è¯æ˜é™åˆ¶ï¼š
** <code>ä¸»ç½‘</code>: 2<sup>224</sup> - 1
** <code>æµ‹è¯•ç½‘ç‰ˆæœ¬ 3</code>: 2<sup>232</sup> - 1
* å—å¤´ä¸­çš„éš¾åº¦ä½å¿…é¡»ä¸é€šè¿‡å°†ASERT éš¾åº¦è®¡ç®—å…¬å¼è®¡ç®—å‡ºçš„ç›®æ ‡éš¾åº¦ç¼–ç ä¸ºç´§å‡‘å½¢å¼è€Œè·å¾—çš„é¢„æœŸéš¾åº¦ä½ç›¸åŒ¹é…
** æ³¨æ„ï¼šå°†ç¼–ç çš„éš¾åº¦ä½ä¸è§£ç çš„ç›®æ ‡éš¾åº¦å€¼è¿›è¡Œæ¯”è¾ƒéå¸¸é‡è¦ï¼Œå› ä¸ºéš¾åº¦ä½ç¼–ç æ ¼å¼ä¼šæˆªæ–­ç›®æ ‡éš¾åº¦ä¸­é™¤æœ€é«˜æœ‰æ•ˆä½ä¹‹å¤–çš„æ‰€æœ‰ä½

ä»¥ä¸‹è§„åˆ™å¿…é¡»è½¬æ¢ä¸ºä½¿ç”¨æœ¬è§„èŒƒå¼•å…¥çš„æ–°PoW å“ˆå¸Œï¼Œè€Œä¸æ˜¯åŒºå—å“ˆå¸Œï¼š

* PoW å“ˆå¸Œå¿…é¡»è¢«è§†ä¸ºå°ç«¯æ— ç¬¦å· 256 ä½æ•´æ•°ï¼Œå¹¶ä¸”å°äºæˆ–ç­‰äºé€šè¿‡è§£ç å—å¤´ä¸­çš„éš¾åº¦ä½è·å¾—çš„ç›®æ ‡éš¾åº¦

==åŸºæœ¬åŸç†==

===ä½æ ¼å¼ä¿ç•™éš¾åº¦===

éš¾åº¦ä½æ ¼å¼æ˜¯ä»é—ç•™ä»£ç ç»§æ‰¿çš„ï¼Œåœ¨å¾ˆå¤šæ–¹é¢éƒ½ä¸å¤ªç†æƒ³ã€‚ä¾‹å¦‚ï¼Œç”±äºåªéœ€è¦å¯¹æ— ç¬¦å· 256 ä½æ•´æ•°çš„ç›®æ ‡å›°éš¾è¿›è¡Œç¼–ç ï¼Œå› æ­¤å®é™…ä¸Šä¸éœ€è¦ç¬¦å·ä½ï¼Œå¹¶ä¸”å®ƒçš„å­˜åœ¨åªä¼šä½¿å®è·µä¸­çš„ç¼–ç å’Œè§£ç å˜å¾—å¤æ‚ã€‚

è¯¥ææ¡ˆå¼ºçƒˆè€ƒè™‘äº†æ›´æ”¹æ ¼å¼ï¼Œä½†æ˜¯ï¼Œå°½ç®¡æœ‰ç¼ºç‚¹ï¼Œç»§æ‰¿çš„æ ¼å¼ä»è¢«ä¿ç•™ï¼Œä»¥å‡å°‘ç”Ÿæ€ç³»ç»Ÿä¸­è½¯ä»¶éœ€è¦å¤„ç†çš„æ›´æ”¹èŒƒå›´ã€‚

===å…¸å‹çš„å¯¹æ•°ç²¾åº¦é™åˆ¶===

è®¸å¤šè¯­è¨€ä½¿ç”¨ 64 ä½æµ®ç‚¹å€¼å®ç°å¯¹æ•°ï¼Œä½†ä»…æä¾› 53 ä½æœ‰æ•ˆä½æ•°çš„ç²¾åº¦ã€‚è¿™æ„å‘³ç€ä¸å¯èƒ½å®Œå…¨è¡¨ç¤ºä»»ä½•å…·æœ‰è¶…è¿‡ 15 åˆ° 17 ä½æœ‰æ•ˆåè¿›åˆ¶æ•°å­—çš„å€¼ï¼ˆå…·ä½“å–å†³äºæŒ‡æ•°ï¼‰ã€‚

ä¾‹å¦‚ï¼Œè€ƒè™‘å€¼ 2<sup>55</sup> - 1 = 36,028,797,018,963,967ã€‚å°†å…¶è½¬æ¢ä¸º 64 ä½æµ®ç‚¹æ•°ï¼Œç„¶åå†è½¬æ¢å›æ— ç¬¦å· 64 ä½æ•´æ•°ï¼Œå°†å¾—åˆ° 36,028,797,018,963,968ï¼Œè€Œä¸æ˜¯åŸå§‹å€¼ã€‚

å½“ç›´æ¥å®ç°æ¶‰åŠå¯¹æ•°çš„å…¬å¼æ—¶ï¼Œè¿™ç§ç²¾åº¦æŸå¤±å¯èƒ½ä¼šå¯¼è‡´ç»“æœä¸å‡†ç¡®ã€‚

å…·ä½“æ¥è¯´ï¼Œè€ƒè™‘éš¾åº¦ä½æ ¼å¼éƒ¨åˆ†ä¸­æä¾›çš„è®¡ç®—æŒ‡æ•°çš„å…¬å¼ï¼Œ è¯¥å…¬å¼æ¶‰åŠä»¥ 256 ä¸ºåº•çš„å¯¹æ•°ã€‚ä»¥ä¸‹ Python ä»£ç ç›´æ¥é€šè¿‡å…¬å¼è®¡ç®—ä¸Šè¿°å€¼ 2 55 - 1 çš„æŒ‡æ•°ï¼Œç»“æœç”Ÿæˆé”™è¯¯çš„æŒ‡æ•° 8ï¼Œè€Œä¸æ˜¯é¢„æœŸçš„æ­£ç¡®å€¼ 7ï¼š

<source lang="python">
import math
def calcExponent(n):
 # WARNING: Incorrect implementation!
 return math.floor(math.log(2 * n) / math.log(256)) + 1

print(calcExponent(2**55 - 1)) # WARNING: Incorrect result!
</source>

å› æ­¤ï¼Œå¼ºçƒˆé¼“åŠ±å…±è¯†ä»£ç çš„å®ç°é¿å…ç›´æ¥æ¶‰åŠå¯¹æ•°çš„å…¬å¼ï¼Œé™¤éå®ƒä»¬èƒ½å¤Ÿå®Œå…¨ä¿è¯è¾“å…¥åŸŸä¸­æ‰€æœ‰å¯èƒ½å€¼çš„æ­£ç¡®ç»“æœã€‚

===ASERTç®—æ³•æ¨å¯¼===

æœ¬ææ¡ˆä¸­æŒ‡å®šçš„ ASERT ç®—æ³•æ˜¯ç†æƒ³æŒ‡æ•°æ–¹ç¨‹çš„è¿‘ä¼¼ï¼š

<!--T_{N} = \mathrm{min}\left(\mathrm{max}\left(T_{s} \cdot \mathrm{e}^{\frac{\Delta t - \Delta h \cdot I_{b}}{\tau}}, 1\right), T_{ub}\right)-->
<img src="asert_ideal.svg" width="100%" height="55" />

æœ‰å…³æœ¯è¯­çš„è§£é‡Šï¼Œ è¯·å‚é˜…[[#asert-difficulty-calculation-formula|è§„èŒƒéƒ¨åˆ†]]ã€‚

ç„¶è€Œï¼Œç”±äº<code>e</code><ref>[[https://en.wikipedia.org/wiki/E_(mathematical_constant)|Wikipedia: e (mathmetical constant)]]</ref>æ˜¯ä¸€ä¸ªè¶…è¶Šæ•°ï¼Œå…±è¯†ä»£ç ä¸­ä½¿ç”¨çš„ä»»ä½•è®¡ç®—éƒ½å¿…é¡»é€‰æ‹©æ˜ç¡®å®šä¹‰çš„è¿‘ä¼¼å€¼æ‰èƒ½è·å¾—å¯é‡ç°çš„ç»“æœã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œè¿‘ä¼¼å€¼åº”è¯¥æ˜¯æ•´æ•°ä»¥é¿å…æµ®ç‚¹æ•°å­¦ã€‚è™½ç„¶ 3 æ˜¯æœ€æ¥è¿‘çš„æ•´æ•°è¿‘ä¼¼å€¼ï¼Œä½†è®¡ç®—æœºåœ¨ä½¿ç”¨ 2 çš„å¹‚è¿›è¡Œè®¡ç®—æ—¶ç‰¹åˆ«é«˜æ•ˆï¼Œå› æ­¤æ¨å¯¼ä»è¿‘ä¼¼eä¸º 2 å¼€å§‹ï¼Œä»è€Œå¾—å‡ºç›®æ ‡æ–¹ç¨‹ï¼š

<!--T_{N} = \mathrm{min}\left(\mathrm{max}\left(T_{s} \cdot 2^{\frac{\Delta t - \Delta h \cdot I_{b}}{\tau}}, 1\right), T_{ub}\right)-->
<img src="asert_goal.svg" width="100%" height="55" />

è¯·æ³¨æ„ï¼Œç›®æ ‡æ–¹ç¨‹æ¶‰åŠåˆ†æ•°æŒ‡æ•°ï¼Œå‡ºäºåŒæ ·çš„åŸå› ï¼ŒåŒæ ·éœ€è¦é€‰æ‹©æ˜ç¡®å®šä¹‰çš„è¿‘ä¼¼å€¼ã€‚ç®€å•åœ°å¯¹æŒ‡æ•°è¿›è¡Œèˆå…¥æˆ–æˆªæ–­ä¼šäº§ç”Ÿè¿‘ä¼¼å€¼ï¼Œä»è€Œå¼•å…¥æ¯”é¢„æœŸæ›´å¤šçš„è¯¯å·®ã€‚ç›¸åï¼Œæ¨å¯¼ä¸­çš„åç»­æ­¥éª¤å°†å…¬å¼é‡æ–°è½¬æ¢ä¸ºè¿‘ä¼¼å€¼ï¼Œè¯¥è¿‘ä¼¼å€¼ä½¿ç”¨å®šç‚¹æ•´æ•°ç®—æœ¯<ref>[[https://en.wikipedia.org/wiki/Fixed-point_arithmetic|Wikipedia: Fixed-point arithmetic]]</ref>å’Œ 2 <sup>x</sup>é¡¹ çš„ä¸‰æ¬¡å¤šé¡¹å¼è¿‘ä¼¼å€¼çš„ç»„åˆã€‚

å®šç‚¹æ•´æ•°è¿ç®—çš„æ¯”ä¾‹å› å­é€‰æ‹©ä¸º 2<sup>16</sup> (x.16 å®šç‚¹)ã€‚è¿™ç§é€‰æ‹©çš„ä¸»è¦åŠ¨æœºæ˜¯ï¼Œå®ƒæä¾›äº†è¶³å¤Ÿçš„ç²¾åº¦ï¼Œä»¥é¿å…å¼•å…¥è¶…è¿‡éš¾åº¦ä½æ ¼å¼äº§ç”Ÿçš„ 2<sup>-15</sup>è¯¯å·® çš„ä»»ä½•é¢å¤–è¯¯å·®ï¼Œå¹¶ä¸”å®ƒä¹Ÿæ˜¯ 2 çš„å¹‚ï¼Œä½¿å¾—é€šè¿‡ä½ç§»ä½è¿›è¡Œè®¡ç®—å˜å¾—é«˜æ•ˆã€‚ä½¿ç”¨è¯¥æ¯”ä¾‹å› å­åº”ç”¨å®šç‚¹ä¿®æ”¹ä¼šäº§ç”Ÿï¼š

<!--T_{N} \approx \mathrm{min}\left(\mathrm{max}\left(\left\lfloor\frac{\left\lfloor2^{16} \cdot T_{s} \cdot 2^{\frac{\Delta t - \Delta h \cdot I_{b}}{\tau}}\right\rfloor}{2^{16}}\right\rfloor, 1\right), T_{ub}\right)-->
<img src="asert_scaled.svg" width="100%" height="119" />

è½¬å‘ 2<sup>x</sup>é¡¹çš„è®¡ç®—ï¼Œåœ¨ 0 â‰¤ x < 1 åŒºé—´å†… 2<sup>x</sup>çš„è‰¯å¥½ç›®æ ‡è¿‘ä¼¼æ˜¯ä¸‰æ¬¡å¤šé¡¹å¼ï¼š

<!--2^{x} \approx 1 + 0.695502049712533x + 0.2262697964x^{2} + 0.0782318x^{3}-->
<img src="asert_two_to_x_approx.svg" width="100%" height="29" />

ä¸‹é¢å¯¼å‡ºçš„è¿™ç§è¿‘ä¼¼çš„æœ€ç»ˆå½¢å¼æä¾›äº† åœ¨ä¸Šè¿° [0,1) åŒºé—´å†… < 0.013% çš„ç»å¯¹è¯¯å·®èŒƒå›´ï¼Œè¿™è¿œä½äºè·å¾—è‰¯å¥½ç»“æœæ‰€éœ€çš„ 0.1% è¯¯å·®èŒƒå›´ã€‚

è¯·è®°ä½ï¼Œå¯¹äºå®šç‚¹æ•´æ•°ç®—æœ¯ï¼Œæ•´ä½“è®¡ç®—å·²æŒ‰ 2<sup>16</sup>ç¼©æ”¾ï¼Œç›®æ ‡è¿‘ä¼¼å€¼ 2<sup>x</sup>çš„ç¼©æ”¾å½¢å¼ä¸ºï¼š

<!--2^{16} \cdot 2^x \approx 2^{16} + 2^{16} \cdot 0.695502049712533x + 2^{16} \cdot 0.2262697964x^2 + 2^{16} \cdot 0.0782318x^3-->
<img src="asert_two_to_x_approx_scaled.svg" width="100%" height="29" />

ç„¶è€Œï¼Œä¸ºäº†åœ¨å…±è¯†å…³é”®ä»£ç ä¸­ä½¿ç”¨ç›®æ ‡è¿‘ä¼¼ï¼Œä»ç„¶éœ€è¦å¤„ç†ä¸€äº›äº‹æƒ…ï¼š

# è¾“å…¥åŸŸä¸å—æœ‰æ•ˆåŒºé—´ [0,1) çš„é™åˆ¶
# æŒ‡æ•°ä¸æ˜¯æ•´æ•°ï¼Œå¯ä»¥ä¸ºè´Ÿæ•°
# ç›®æ ‡è¿‘ä¼¼å…¬å¼æ¶‰åŠéæ•´æ•°ç³»æ•°

ä¸ºäº†è·å¾—æ­£ç¡®çš„è¾“å…¥åŸŸï¼Œè¯·æ³¨æ„æŒ‡æ•°è§„åˆ™ 2<sup>n+f</sup> = 2<sup>n</sup> x 2<sup>f</sup>ã€‚åˆ©ç”¨è¿™ä¸€äº‹å®ï¼ŒæŒ‡æ•°è¢«åˆ†è§£ä¸ºæ•´æ•°éƒ¨åˆ† n å’Œå°æ•°éƒ¨åˆ† fï¼Œä½¿å¾— f ä½äºæ‰€éœ€çš„ [0,1) èŒƒå›´å†…ã€‚ç„¶åï¼Œé€šè¿‡å°†ç¼©æ”¾çš„ä¸‰æ¬¡å¤šé¡¹å¼è¿‘ä¼¼åº”ç”¨äºå°æ•°éƒ¨åˆ†å¹¶ä¹˜ä»¥ 2<sup>n</sup>æ¥è®¡ç®—ç»“æœã€‚

ä¸ºäº†ä½¿æŒ‡æ•°æˆä¸ºæ•´æ•°ï¼Œå®ƒè¿˜è¢«ç¼©æ”¾ 2<sup>16</sup>å¹¶é€šè¿‡å®šç‚¹æ•´æ•°ç®—æœ¯è®¡ç®—ã€‚è¯·æ³¨æ„ï¼Œè¿™æ„å‘³ç€ä¸Šè¿°åˆ†è§£ä¸­çš„æ•´æ•°éƒ¨åˆ† n å’Œå°æ•°éƒ¨åˆ† f ä¹ŸæŒ‰ 2<sup>16</sup>ç¼©æ”¾ã€‚

æ­¤å¤–ï¼Œç”±äºæŒ‡æ•°å¯ä»¥ä¸ºè´Ÿæ•°å¹¶ä¸”æ¶‰åŠé™¤æ³•ï¼Œå› æ­¤éœ€è¦é€‰æ‹©æ˜¯å‘ 0 èˆå…¥ï¼ˆæˆªæ–­ï¼‰è¿˜æ˜¯å‘è´Ÿæ— ç©·å¤§ï¼ˆä¸‹å–æ•´ï¼‰èˆå…¥ã€‚ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œæ­¤å®ç°é€‰æ‹©æˆªæ–­é™¤æ³•ï¼Œå› ä¸ºé™¤æ³•æ˜¯æŒ‰ä¸æ˜¯ 2 çš„å¹‚çš„é¡¹è¿›è¡Œçš„ï¼Œå¹¶ä¸”å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€éƒ½ä½¿ç”¨å…¶å†…ç½®è¿ç®—ç¬¦å®ç°æˆªæ–­é™¤æ³•ã€‚å¦ä¸€æ–¹é¢ï¼Œä¸‹é™å¯¹äºæ¶‰åŠ 2 çš„å¹‚çš„é™¤æ³•æ¥è¯´æ˜¯é¦–é€‰ï¼Œå› ä¸ºå®ƒå¯ä»¥é€šè¿‡ç®—æœ¯ç§»ä½æ¥æœ‰æ•ˆåœ°è®¡ç®—ï¼Œå…¶è¡Œä¸ºä¸ä¸‹é™å‡½æ•°ç›¸åŒã€‚

è€ƒè™‘åˆ°æ‰€æœ‰å› ç´ ï¼Œå¾—åˆ°çš„è¿‘ä¼¼æŒ‡æ•°å’Œåˆ†è§£ä¸ºï¼š

<!--x = \rm{Int}\left(\frac{2^{16}(\Delta t - \Delta h \cdot I_{b})}{\tau}\right)-->
<!--n = \left\lfloor\frac{x}{2^{16}}\right\rfloor-->
<!--f = x\bmod{2^{16}}-->
<img src="asert_exponent_decomp.svg" width="100%" height="98" />

å°†ç¼©æ”¾å°æ•°éƒ¨åˆ†ä»£å…¥ç¼©æ”¾ç›®æ ‡è¿‘ä¼¼å€¼ 2<sup>x</sup>å¹¶é™¤ä»¥å¼•å…¥çš„é™„åŠ ç¼©æ”¾å› å­ï¼Œå¾—åˆ°ï¼š

<!--
F \approx 2^{16} + \left\lfloor \frac{\lceil2^{48} \cdot 0.695502049712533f\rceil+ \lceil2^{32} \cdot 0.2262697964f^2\rceil + \lceil2^{16} \cdot 0.0782318f^3\rceil  + 2^{47}}{2^{48}}\right\rfloor
F \approx 2^{16} + \left\lfloor \frac{195766423245049f + 971821376f^2 + 5127f^3 + 2^{47}}{2^{48}}\right\rfloor \\
-->
<img src="asert_fractional_substitution.svg" width="100%" height="141" />

æ¥ä¸‹æ¥ï¼Œé€šè¿‡ä¹˜ä»¥å‰©ä½™çš„ç¼©æ”¾å› å­å¹¶å–ä¸Šé™ï¼Œå°†ç³»æ•°è½¬æ¢ä¸ºæ•´æ•°ã€‚æ­¤å¤–ï¼Œè¿˜åœ¨åº•é™å†…æ·»åŠ äº†é¢å¤–çš„ 2<sup>47</sup>é¡¹ä»¥è¿›è¡Œå››èˆäº”å…¥ã€‚è¿™äº›ä¿®æ”¹çš„ç»“æœæ˜¯ï¼š

<!--
F \approx 2^{16} + \left\lfloor \frac{\left\lceil2^{48} \cdot 0.695502049712533f\right\rceil+ \left\lceil2^{32} \cdot 0.2262697964f^2\right\rceil + \left\lceil2^{16} \cdot 0.0782318f^3\right\rceil  + 2^{47}}{2^{48}}\right\rfloor
F \approx 2^{16} + \left\lfloor \frac{195766423245049f + 971821376f^2 + 5127f^3 + 2^{47}}{2^{48}}\right\rfloor
-->
<img src="asert_fractional_approx.svg" width="100%" height="170" />

æœ€åï¼Œå°† 2<sup>x</sup>è¿‘ä¼¼çš„æ•´æ•°å’Œå°æ•°éƒ¨åˆ†ä»£å…¥ç›®æ ‡æ–¹ç¨‹çš„åŸå§‹å®šç‚¹å…¬å¼ä¸­ï¼Œä»¥è®¡ç®—ç›®æ ‡éš¾åº¦ï¼ŒåŒæ—¶è¿˜è§‚å¯Ÿåˆ°ï¼Œé€šè¿‡æŒ‡æ•°è§„åˆ™ 2<sup>n</sup> / 2<sup>16</sup> = 2<sup>n-16</sup>ï¼Œå¾—å‡ºè§„èŒƒä¸­ä½¿ç”¨çš„æœ€ç»ˆå½¢å¼ï¼š

<!--T_{N} = \mathrm{min}\left(\mathrm{max}\left(\left\lfloor T_{s} \cdot F \cdot 2^{n-16}\right\rfloor, 1\right), T_{ub}\right)-->
<img src="asert_final_form.svg" width="100%" height="37" />

===ASERT ç›¸å¯¹ä¸‰æ¬¡å¤šé¡¹å¼è¿‘ä¼¼è¯¯å·®===

ä¸‹å›¾æ˜¾ç¤ºäº†æœ¬è§„èŒƒä¸­ä½¿ç”¨çš„å®šç‚¹è¿‘ä¼¼åœ¨ [0,1) èŒƒå›´å†…ç›¸å¯¹ è¿‘ä¼¼è¯¯å·®ä¸ 2<sup>x</sup>çš„å…³ç³»ï¼š

<img src="asert_rel_cubic_poly_approx_err_10k.svg" width="100%" height="748" />

==æ¨¡æ‹Ÿå›¾==

ä¸‹å›¾æä¾›äº†ä½¿ç”¨å…·æœ‰ä¸»è¦ç½‘ç»œå‚æ•°çš„æ–°ç®—æ³•æ¨¡æ‹Ÿä¸‰ä¸ªæŒ–æ˜åœºæ™¯çš„ç»“æœçš„å¯è§†åŒ–ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™äº›åœºæ™¯ä¸­çš„æ¯ä¸€ä¸ªéƒ½æ¶‰åŠéšæœºæ±‚è§£æ—¶é—´ï¼Œè¿™äº›æ—¶é—´éµå¾ªç›®æ ‡å¹³å‡åŒºå—æ—¶é—´çš„æ³Šæ¾åˆ†å¸ƒï¼Œä»¥ä¾¿æ¨¡æ‹ŸçœŸå®çš„æŒ–æ˜è¡Œä¸ºã€‚

ä¸ºæ¯ä¸ªåœºæ™¯æä¾›äº†ä¸¤ä¸ªå›¾è¡¨ï¼š

* æ¯ä¸ªå—çš„éš¾åº¦æ¯”ï¼Œä»¥è¯´æ˜éš¾åº¦ç®—æ³•çš„è¡Œä¸ºå’Œå“åº”èƒ½åŠ›
* æ±‚è§£æ—¶é—´çš„ç›´æ–¹å›¾ä¸ç†æƒ³æ³Šæ¾åˆ†å¸ƒé‡å ï¼Œä»¥è¯´æ˜æ¨¡æ‹Ÿéµå¾ªæ‰€éœ€çš„å®é™…æ³Šæ¾åˆ†å¸ƒ

è¿™äº›åœºæ™¯ä»¥åŠå…¶ä»–å‡ ä¸ªåœºæ™¯ä¹ŸåŒ…å«åœ¨ [[#asert-difficulty-calculations|ASERT å‚è€ƒæµ‹è¯•å‘é‡]]ä¸­ã€‚

===åœºæ™¯ï¼šç®—åŠ›ç¨³å®š===

è¯¥åœºæ™¯é€šè¿‡å°†å¹³å‡æ±‚è§£æ—¶é—´è®¾å®šä¸º 300 ç§’æ¥æ¨¡æ‹Ÿç¨³å®šçš„ç®—åŠ›ï¼Œè¯¥æ—¶é—´ä¸ä¸»ç½‘ç»œçš„å®é™…ç›®æ ‡å¹³å‡å‡ºå—æ—¶é—´ç›¸åŒ¹é…ã€‚é€šè¿‡å¯¹æ¯ä¸ªåŒºå—è¿›è¡Œç»†å¾®è°ƒæ•´ï¼Œéš¾åº¦ä¿æŒç›¸å½“ç¨³å®šï¼Œä»¥ç»´æŒæ‰€éœ€çš„åŒºå—ç”Ÿäº§ç‡ã€‚

<img src="asert_stable.svg" width="100%" height="623" />

===åœºæ™¯ï¼šç®—åŠ›å¿«é€Ÿæå‡===

è¯¥åœºæ™¯é€šè¿‡å°†å¹³å‡æ±‚è§£æ—¶é—´è®¾å®šä¸º 15 ç§’æ¥æ¨¡æ‹Ÿç®—åŠ›çš„å¿«é€Ÿå¢é•¿ï¼Œè¿™æ¯”ä¸»ç½‘ç»œçš„å®é™…ç›®æ ‡å¹³å‡å‡ºå—æ—¶é—´è¦å¿«å¾—å¤šã€‚ä¸ºäº†å°†åŒºå—ç”Ÿäº§ç‡é™ä½å›åˆ°æœŸæœ›çš„ç›®æ ‡ï¼Œéš¾åº¦è¿…é€Ÿå¢åŠ ã€‚

<img src="asert_increasing.svg" width="100%" height="621" />

===åœºæ™¯ï¼šç®—åŠ›å¿«é€Ÿä¸‹é™===

è¯¥åœºæ™¯é€šè¿‡å°†å¹³å‡æ±‚è§£æ—¶é—´è®¾å®šä¸º 1000 ç§’æ¥æ¨¡æ‹Ÿç®—åŠ›çš„å¿«é€Ÿä¸‹é™ï¼Œè¯¥æ—¶é—´æ¯”ä¸»ç½‘ç»œçš„å®é™…ç›®æ ‡å¹³å‡å‡ºå—æ—¶é—´æ…¢å¾—å¤šã€‚ä¸ºäº†å°†åŒºå—ç”Ÿäº§ç‡æé«˜å›é¢„æœŸç›®æ ‡ï¼Œéš¾åº¦è¿…é€Ÿé™ä½ã€‚

<img src="asert_decreasing.svg" width="100%" height="622" />

==éƒ¨ç½²==

===æŠ•ç¥¨è®®ç¨‹å‚æ•°===

è¯¥ææ¡ˆå°†ä½¿ç”¨æ ‡å‡† Decred é“¾ä¸ŠæŠ•ç¥¨åŸºç¡€è®¾æ–½éƒ¨ç½²åˆ°ä¸»ç½‘ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š


{|
!åç§°!!è®¾ç½®
|-
|éƒ¨ç½²ç‰ˆæœ¬||10
|-
|è®®ç¨‹ç¼–å·||blake3pow
|-
|è®®ç¨‹è¯´æ˜||å°†å·¥ä½œé‡è¯æ˜å“ˆå¸Œç®—æ³•æ›´æ”¹ä¸º DCP0011 ä¸­å®šä¹‰çš„ BLAKE3
|-
|å¼€å§‹æ—¶é—´||1682294400 (4æœˆ24æ—¥, 2023 00:00:00 +0000 UTC)
|-
|è¿‡æœŸæ—¶é—´||1745452800 (4æœˆ24æ—¥, 2025 00:00:00 +0000 UTC)
|-
|Mask||0x0006 (Bits 1 å’Œ 2)
|-
|é€‰æ‹©||{|
!é€‰æ‹©!!è¯´æ˜!!Bits
|-
|å¼ƒæƒ||å¯¹å˜æ›´æŠ•å¼ƒæƒç¥¨||0x00
|-
|å¦å†³||ä¿ç•™ç°æœ‰çš„å…±è¯†è§„åˆ™||0x0002 (Bit 1)
|-
|æ”¯æŒ||æ›´æ”¹æ–°çš„å…±è¯†è§„åˆ™	||0x0004 (Bit 2)
|}
|}

===æŠ•ç¥¨ç»“æœ===

è¯¥ææ¡ˆå·²è·å¾—åˆ©ç›Šç›¸å…³è€…æŠ•ç¥¨ç¨‹åºçš„æ‰¹å‡†ï¼Œç°å·²ç”Ÿæ•ˆã€‚


{|
!ä½ç½®!!åŒºå—å“ˆå¸Œ!!åŒºå—é«˜åº¦
|-
|æŠ•ç¥¨å¼€å§‹||0000000000000000d608dc4ec7fcae5c650353db68a77f2954df74c25462f337||778240
|-
|æŠ•ç¥¨é”å®š||0000000000000000896042b2b0536a4046e56ef505f20f7301ca7e042a5c218e||786304
|-
|æ¿€æ´»||071683030010299ab13f139df59dc98d637957b766e47f8da6dd5ac762f1e8c7||794368
|}

==å…¼å®¹æ€§==

è¿™æ˜¯å¯¹ Decred å…±è¯†çš„ç¡¬åˆ†å‰æ”¹å˜ã€‚è¿™æ„å‘³ç€ä¸€æ—¦è®®ç¨‹è¢«æŠ•ç¥¨å¹¶è¢«é”å®šï¼Œä»»ä½•è¿è¡Œå®Œå…¨éªŒè¯åŒºå—çš„ä»£ç çš„äººéƒ½å¿…é¡»åœ¨æ¿€æ´»æ—¶é—´ä¹‹å‰å‡çº§ï¼Œå¦åˆ™ä»–ä»¬å°†æ‹’ç»æ‰€æœ‰æ–°åŒºå—ï¼Œå› ä¸ºä»–ä»¬çš„å·¥ä½œè¯æ˜åœ¨æ—§è§„åˆ™ä¸‹æ— æ•ˆã€‚

æ‰§è¡Œå®Œæ•´éªŒè¯çš„å…¶ä»–è½¯ä»¶å°†éœ€è¦ç›¸åº”åœ°ä¿®æ”¹å…¶å…±è¯†æ‰§è¡Œè§„åˆ™ï¼Œå¹¶ä¸”æ‰§è¡Œæ ‡å¤´éªŒè¯çš„ä»»ä½•è½¯ä»¶ï¼ˆä¾‹å¦‚è½»é‡çº§é’±åŒ…å’Œå…¶ä»– SPV å®¢æˆ·ç«¯ï¼‰å°†éœ€è¦æ›´æ–°ä»¥å¤„ç†æ­¤å¤„æŒ‡å®šçš„æ›´æ”¹ã€‚

==å‚è€ƒå®ç°==

ä»¥ä¸‹å®ç°æ˜¯ç®€åŒ–ç‰ˆæœ¬ï¼Œæ—¨åœ¨é€šè¿‡ç‹¬ç«‹å‡½æ•°æ¸…æ¥šåœ°è¯´æ˜æœ¬è§„èŒƒçš„ç¡®åˆ‡è¯­ä¹‰ã€‚è¯·å‚é˜…[[#pull-requests|åˆå¹¶è¯·æ±‚]]éƒ¨åˆ†ä»¥è·å–å®Œæ•´å®ç°çš„é“¾æ¥ã€‚

===å·¥ä½œé‡è¯æ˜å“ˆå¸Œè®¡ç®—===

<source lang="go">
import (
	"encoding/binary"
	"lukechampine.com/blake3"
)

// putUint8 writes the passed uint8 to the provided slice and returns 1 to
// signify the number of bytes written.  The target byte slice must be at least
// large enough to handle the write or it will panic.
func putUint8(buf []byte, val uint8) int {
	buf[0] = val
	return 1
}

// putUint16LE writes the provided uint16 as little endian to the provided slice
// and returns 2 to signify the number of bytes written.  The target byte slice
// must be at least large enough to handle the write or it will panic.
func putUint16LE(buf []byte, val uint16) int {
	binary.LittleEndian.PutUint16(buf, val)
	return 2
}

// putUint32LE writes the provided uint32 as little endian to the provided slice
// and returns 4 to signify the number of bytes written.  The target byte slice
// must be at least large enough to handle the write or it will panic.
func putUint32LE(buf []byte, val uint32) int {
	binary.LittleEndian.PutUint32(buf, val)
	return 4
}

// putUint64LE writes the provided uint64 as little endian to the provided slice
// and returns 8 to signify the number of bytes written.  The target byte slice
// must be at least large enough to handle the write or it will panic.
func putUint64LE(buf []byte, val uint64) int {
	binary.LittleEndian.PutUint64(buf, val)
	return 8
}

// blake3PowHash computes the BLAKE3 proof of work hash for the given block
// header fields.
func blake3PowHash(version int32, prevBlockHash, merkleRoot,
	commitmentRoot [32]byte, voteBits uint16, finalState [6]byte,
	numVoters uint16, freshStake, revocations uint8, poolSize,
	diffBits uint32, stakeDiff int64, blockHeight, blockSize uint32,
	timestamp uint32, extraData [36]byte, stakeVersion uint32) [32]byte {

	var target [180]byte
	offset := putUint32LE(target[0:], uint32(version))
	offset += copy(target[offset:], prevBlockHash[:])
	offset += copy(target[offset:], merkleRoot[:])
	offset += copy(target[offset:], commitmentRoot[:])
	offset += putUint16LE(target[offset:], voteBits)
	offset += copy(target[offset:], finalState[:])
	offset += putUint16LE(target[offset:], numVoters)
	offset += putUint8(target[offset:], freshStake)
	offset += putUint8(target[offset:], revocations)
	offset += putUint32LE(target[offset:], poolSize)
	offset += putUint32LE(target[offset:], diffBits)
	offset += putUint64LE(target[offset:], uint64(stakeDiff))
	offset += putUint32LE(target[offset:], blockHeight)
	offset += putUint32LE(target[offset:], blockSize)
	offset += putUint32LE(target[offset:], timestamp)
	offset += copy(target[offset:], extraData[:])
	putUint32LE(target[offset:], stakeVersion)
	return blake3.Sum256(target[:])
}
</source>

===æ¯”ç‰¹è§£ç éš¾åº¦===

<source lang="go">
// diffBitsToBig converts the compact representation used to encode difficulty
// targets to a big integer.  The representation is similar to IEEE754 floating
// point numbers.
//
// Like IEEE754 floating point, there are three basic components: the sign,
// the exponent, and the mantissa.  They are broken out as follows:
//
//  1. the most significant 8 bits represent the unsigned base 256 exponent
//  2. zero-based bit 23 (the 24th bit) represents the sign bit
//  3. the least significant 23 bits represent the mantissa
//
// Diagram:
//
//	-------------------------------------------------
//	|   Exponent     |    Sign    |    Mantissa     |
//	|-----------------------------------------------|
//	| 8 bits [31-24] | 1 bit [23] | 23 bits [22-00] |
//	-------------------------------------------------
//
// The formula to calculate the encoded difficulty target is:
//
//	T = (-1)^sign * floor(mantissa * 256^(exponent-3))
func diffBitsToBig(bits uint32) *big.Int {
	// Extract the mantissa, sign bit, and exponent.
	mantissa := bits & 0x007fffff
	isNegative := bits&0x00800000 != 0
	exponent := uint(bits >> 24)

	// Since the base for the exponent is 256, the exponent can be treated as
	// the number of bytes to represent the full 256-bit number.  So, treat the
	// exponent as the number of bytes and shift the mantissa right or left
	// accordingly.  This is equivalent to:
	// T = mantissa * 256^(exponent-3)
	var bn *big.Int
	if exponent <= 3 {
		mantissa >>= 8 * (3 - exponent)
		bn = big.NewInt(int64(mantissa))
	} else {
		bn = big.NewInt(int64(mantissa))
		bn.Lsh(bn, 8*(exponent-3))
	}

	// Make it negative if the sign bit is set.
	if isNegative {
		bn = bn.Neg(bn)
	}

	return bn
}
</source>

===æ¯”ç‰¹éš¾åº¦ç¼–ç ===

<source lang="go">
// bigToDiffBits converts a big integer to the compact representation used to
// encode difficulty targets as an unsigned 32-bit integer.  The compact
// representation only provides 23 bits of precision, so values larger than
// (2^23 - 1) only encode the most significant bits of the number.
func bigToDiffBits(t *big.Int) uint32 {
	// No need to do any work if it's zero.
	if t.Sign() == 0 {
		return 0
	}

	// Since the base for the exponent is 256, the exponent can be treated as
	// the number of bytes.  So, shift the number right or left accordingly.
	// This is equivalent to:
	// mantissa = mantissa / 256^(exponent-3)
	var mantissa uint32
	exponent := uint(len(t.Bytes()))
	if exponent <= 3 {
		mantissa = uint32(t.Bits()[0])
		mantissa <<= 8 * (3 - exponent)
	} else {
		// Use a copy to avoid modifying the caller's original number.
		tt := new(big.Int).Set(t)
		tt.Abs(tt)
		mantissa = uint32(tt.Rsh(tt, 8*(exponent-3)).Bits()[0])
	}

	// When the mantissa already has the sign bit set, the number is too large
	// to fit into the available 23-bits, so divide the number by 256 and
	// increment the exponent accordingly.
	if mantissa&0x00800000 != 0 {
		mantissa >>= 8
		exponent++
	}

	// Pack the exponent, sign bit, and mantissa into an unsigned 32-bit int and
	// return it.
	bits := uint32(exponent<<24) | mantissa
	if t.Sign() < 0 {
		bits |= 0x00800000
	}
	return bits
}
</source>

===ASERT éš¾åº¦è®¡ç®—===

<source lang="go">
// calcASERTDiff calculates a target difficulty for the given set of parameters
// using the ASERT algorithm and returns that target encoded as difficulty bits.
func calcASERTDiff(startDiffBits uint32, powLimit *big.Int, targetSecsPerBlock,
	timeDelta, heightDelta, halfLife int64) uint32 {

	// Ensure parameter assumptions are not violated.
	//
	// 1. The starting target difficulty must be in the range [1, powLimit]
	// 2. The height to calculate the difficulty for must come after the height
	//    of the reference block
	startDiff := diffBitsToBig(startDiffBits)
	if startDiff.Sign() <= 0 || startDiff.Cmp(powLimit) > 0 {
		panic(fmt.Sprintf("starting difficulty %064x is not in the valid "+
			"range [1, %064x]", startDiff, powLimit))
	}
	if heightDelta < 0 {
		panic(fmt.Sprintf("provided height delta %d is negative", heightDelta))
	}

	// Calculate the target difficulty by multiplying the provided starting
	// target difficulty by an exponential scaling factor that is determined
	// based on how far ahead or behind the ideal schedule the given time delta
	// is along with a half life that acts as a smoothing factor.
	//
	// Per DCP0011, the goal equation is:
	//
	//   nextDiff = min(max(startDiff * 2^((Î”t - Î”h*Ib)/halfLife), 1), powLimit)
	//
	// However, in order to avoid the need to perform floating point math which
	// is problematic across languages due to uncertainty in floating point math
	// libs, the formula is implemented using a combination of fixed-point
	// integer arithmetic and a cubic polynomial approximation to the 2^x term.
	//
	// In particular, the goal cubic polynomial approximation over the interval
	// 0 <= x < 1 is:
	//
	//   2^x ~= 1 + 0.695502049712533x + 0.2262697964x^2 + 0.0782318x^3
	//
	// This approximation provides an absolute error margin < 0.013% over the
	// aforementioned interval of [0,1) which is well under the 0.1% error
	// margin needed for good results.  Note that since the input domain is not
	// constrained to that interval, the exponent is decomposed into an integer
	// part, n, and a fractional part, f, such that f is in the desired range of
	// [0,1).  By exponent rules 2^(n + f) = 2^n * 2^f, so the strategy is to
	// calculate the result by applying the cubic polynomial approximation to
	// the fractional part and using the fact that multiplying by 2^n is
	// equivalent to an arithmetic left or right shift depending on the sign.
	//
	// In other words, start by calculating the exponent (x) using 64.16 fixed
	// point and decompose it into integer (n) and fractional (f) parts as
	// follows:
	//
	//       2^16 * (Î”t - Î”h*Ib)   (Î”t - Î”h*Ib) << 16
	//   x = ------------------- = ------------------
	//            halfLife              halfLife
	//
	//        x
	//   n = ---- = x >> 16
	//       2^16
	//
	//   f = x (mod 2^16) = x & 0xffff
	//
	// The use of 64.16 fixed point for the exponent means both the integer (n)
	// and fractional (f) parts have an additional factor of 2^16.  Since the
	// fractional part of the exponent is cubed in the polynomial approximation
	// and (2^16)^3 = 2^48, the addition step in the approximation is internally
	// performed using 16.48 fixed point to compensate.
	//
	// In other words, the fixed point formulation of the goal cubic polynomial
	// approximation for the fractional part is:
	//
	//                 195766423245049*f + 971821376*f^2 + 5127*f^3 + 2^47
	//   2^f ~= 2^16 + ---------------------------------------------------
	//                                          2^48
	//
	// Finally, the final target difficulty is calculated using x.16 fixed point
	// and then clamped to the valid range as follows:
	//
	//              startDiff * 2^f * 2^n
	//   nextDiff = ---------------------
	//                       2^16
	//
	//   nextDiff = min(max(nextDiff, 1), powLimit)
	//
	// NOTE: The division by the half life uses Quo instead of Div because it
	// must be truncated division (which is truncated towards zero as Quo
	// implements) as opposed to the Euclidean division that Div implements.
	idealTimeDelta := heightDelta * targetSecsPerBlock
	exponentBig := big.NewInt(timeDelta - idealTimeDelta)
	exponentBig.Lsh(exponentBig, 16)
	exponentBig.Quo(exponentBig, big.NewInt(halfLife))

	// Decompose the exponent into integer and fractional parts.  Since the
	// exponent is using 64.16 fixed point, the bottom 16 bits are the
	// fractional part and the integer part is the exponent arithmetic right
	// shifted by 16.
	frac64 := uint64(exponentBig.Int64() & 0xffff)
	shifts := exponentBig.Rsh(exponentBig, 16).Int64()

	// Calculate 2^16 * 2^(fractional part) of the exponent.
	//
	// Note that a full unsigned 64-bit type is required to avoid overflow in
	// the internal 16.48 fixed point calculation.  Also, the overall result is
	// guaranteed to be positive and a maximum of 17 bits, so it is safe to cast
	// to a uint32.
	const (
		polyCoeff1 uint64 = 195766423245049 // ceil(0.695502049712533 * 2^48)
		polyCoeff2 uint64 = 971821376       // ceil(0.2262697964 * 2^32)
		polyCoeff3 uint64 = 5127            // ceil(0.0782318 * 2^16)
	)
	fracFactor := uint32(1<<16 + (polyCoeff1*frac64+
		polyCoeff2*frac64*frac64+
		polyCoeff3*frac64*frac64*frac64+
		1<<47)>>48)

	// Calculate the target difficulty per the previous discussion:
	//
	//              startDiff * 2^f * 2^n
	//   nextDiff = ---------------------
	//                       2^16
	//
	// Note that by exponent rules 2^n / 2^16 = 2^(n - 16).  This takes
	// advantage of that property to reduce the multiplication by 2^n and
	// division by 2^16 to a single shift.
	//
	// This approach also has the benefit of lowering the maximum magnitude
	// relative to what would be the case when first left shifting by a larger
	// value and then right shifting after.  Since arbitrary precision integers
	// are used for this implementation, it doesn't make any difference from a
	// correctness standpoint, however, it does potentially lower the amount of
	// memory for the arbitrary precision type and can be used to help prevent
	// overflow in implementations that use fixed precision types.
	nextDiff := new(big.Int).Set(startDiff)
	nextDiff.Mul(nextDiff, big.NewInt(int64(fracFactor)))
	shifts -= 16
	if shifts >= 0 {
		nextDiff.Lsh(nextDiff, uint(shifts))
	} else {
		nextDiff.Rsh(nextDiff, uint(-shifts))
	}

	// Limit the target difficulty to the valid hardest and easiest values.
	// The valid range is [1, powLimit].
	if nextDiff.Sign() == 0 {
		// The hardest valid target difficulty is 1 since it would be impossible
		// to find a non-negative integer less than 0.
		nextDiff.SetInt64(1)
	} else if nextDiff.Cmp(powLimit) > 0 {
		nextDiff.Set(powLimit)
	}

	// Convert the difficulty to the compact representation and return it.
	return bigToDiffBits(nextDiff)
}
</source>

===åˆå¹¶è¯·æ±‚===

====éƒ¨ç½²====

æ‰€éœ€è®®ç¨‹å®šä¹‰çš„å‚è€ƒå®ç°æ˜¯é€šè¿‡[[https://github.com/decred/dcrd/pull/3089|pull request #3089]]å®ç°.

====å…±è¯†æ‰§è¡Œå’ŒæŠ•ç¥¨====

[[https://github.com/decred/dcrd/pull/3115|pull request #3115]]æä¾›äº†æ‰§è¡Œæœ¬ææ¡ˆä¸­æŒ‡å®šçš„æ›´æ”¹æ‰€éœ€çš„å…±è¯†æ›´æ”¹çš„å‚è€ƒå®ç° ã€‚.

==æµ‹è¯•è½½ä½“==

æä¾›ä»¥ä¸‹æµ‹è¯•å‘é‡æ˜¯ä¸ºäº†ä¿ƒè¿›è·¨å®ç°çš„æµ‹è¯•ã€‚

æµ‹è¯•å‘é‡å‡ä»¥ JSON å½¢å¼æä¾›ï¼Œä»¥ä¾¿å®ç°å¯ä»¥è½»æ¾å¤åˆ¶å®ƒä»¬å¹¶ä»¥ç¼–ç¨‹æ–¹å¼è§£æå®ƒä»¬ä»¥é¿å…è½¬ç½®é”™è¯¯ã€‚

===BLAKE3 å·¥ä½œå“ˆå¸Œè¯æ˜===

ç”¨äº BLAKE3 å·¥ä½œé‡è¯æ˜è®¡ç®—çš„ JSON æµ‹è¯•å‘é‡å¯åœ¨ [[blake3_powhash_test_vectors.json]].ä¸­æ‰¾åˆ°ã€‚

æµ‹è¯•æ•°æ®ç”±ä¸€ç³»åˆ—å—å¤´å­—æ®µç»„æˆï¼Œç”¨äºåºåˆ—åŒ–ä»¥æ„å»º BLAKE3 å·¥ä½œè¯æ˜å“ˆå¸Œå€¼ä»¥åŠé¢„æœŸå“ˆå¸Œå€¼ã€‚ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œå®ƒè¿˜æä¾›äº†é¢„æœŸçš„åºåˆ—åŒ–åŸåƒï¼Œå› æ­¤å¦‚æœå®ç°æ²¡æœ‰è·å¾—é¢„æœŸçš„ PoW å“ˆå¸Œï¼Œåˆ™å¯ä»¥äº¤å‰æ£€æŸ¥å“ˆå¸Œå‡½æ•°çš„é¢„æœŸè¾“å…¥ã€‚

æœ€åï¼Œé¡¶éƒ¨é™„è¿‘æä¾›äº†æ³¨é‡Šï¼Œæè¿°äº†æ¯ä¸ªå­—æ®µçš„æ ¼å¼ã€‚

ä»¥ä¸‹ç¤ºä¾‹ Go ä»£ç æä¾›äº†ä¸€ä¸ªæµ‹è¯•å‡½æ•°ï¼Œç”¨äºåŠ è½½å’Œè§£ææ–‡ä»¶ã€æ‰§è¡Œæ‰€æœ‰æµ‹è¯•å¹¶éªŒè¯ç»“æœï¼š

<source lang="go">
func blake3PowHash(version int32, prevBlockHash, merkleRoot,
	commitmentRoot [32]byte, voteBits uint16, finalState [6]byte,
	numVoters uint16, freshStake, revocations uint8, poolSize,
	diffBits uint32, stakeDiff int64, blockHeight, blockSize uint32,
	timestamp uint32, extraData [36]byte, stakeVersion uint32) [32]byte {

	// Your implementation...
	return [32]byte{}
}

func TestPoWHash(t *testing.T) {
	// Read and parse the reference test vectors.
	f, err := os.ReadFile("blake3_powhash_test_vectors.json")
	if err != nil {
		t.Fatalf("failed to read test vectors: %v", err)
	}
	var testData struct {
		Comments []string `json:"comments"`
		Tests    []struct {
			Version        int32  `json:"version"`
			PrevHash       string `json:"prevHash"`
			MerkleRoot     string `json:"merkleRoot"`
			CommitmentRoot string `json:"commitmentRoot"`
			VoteBits       uint16 `json:"voteBits"`
			FinalState     string `json:"finalState"`
			NumVoters      uint16 `json:"numVoters"`
			FreshStake     uint8  `json:"freshStake"`
			Revocations    uint8  `json:"revocations"`
			PoolSize       uint32 `json:"poolSize"`
			DiffBits       uint32 `json:"diffBits"`
			StakeDiff      int64  `json:"stakeDiff"`
			BlockHeight    uint32 `json:"blockHeight"`
			BlockSize      uint32 `json:"blockSize"`
			Timestamp      uint32 `json:"timestamp"`
			ExtraData      string `json:"extraData"`
			StakeVersion   uint32 `json:"stakeVersion"`
			Serialized     string `json:"serialized"`
			PowHash        string `json:"powHash"`
		} `json:"tests"`
	}
	err = json.Unmarshal(f, &testData)
	if err != nil {
		t.Fatalf("parse failed: %v", err)
	}

	// Define a couple of convenience methods for parsing the hex-encoded data
	// and hashes.
	parseHex := func(data string) []byte {
		t.Helper()

		decoded, err := hex.DecodeString(data)
		if err != nil {
			t.Fatalf("unable to parse test data: %v", err)
		}
		return decoded
	}
	parseHash := func(data string) [32]byte {
		t.Helper()

		const hashSize = 32
		hash := parseHex(data)
		if len(hash) != hashSize {
			t.Fatalf("invalid hash len -- got %d, want %d", len(hash), hashSize)
		}

		// Reverse the hash so it matches the raw bytes that are produced by the
		// hash func.
		var reversed [hashSize]byte
		for i := 0; i < hashSize/2; i++ {
			reversed[i], reversed[hashSize-1-i] = hash[hashSize-1-i], hash[i]
		}
		return reversed
	}
	for i, test := range testData.Tests {
		// Ensure the test data for the serialized header actually produces the
		// provided pow hash.
		hashFromInput := blake3.Sum256(parseHex(test.Serialized))
		wantPowHash := parseHash(test.PowHash)
		if hashFromInput != wantPowHash {
			t.Fatalf("bad test data: provided input to the hash func does "+
				"not hash to the provided pow hash -- got: %x, want: %x",
				hashFromInput, wantPowHash)
		}

		gotHash := blake3PowHash(test.Version, parseHash(test.PrevHash),
			parseHash(test.MerkleRoot), parseHash(test.CommitmentRoot),
			test.VoteBits, *(*[6]byte)(parseHex(test.FinalState)),
			test.NumVoters, test.FreshStake, test.Revocations, test.PoolSize,
			test.DiffBits, test.StakeDiff, test.BlockHeight, test.BlockSize,
			test.Timestamp, *(*[36]byte)(parseHex(test.ExtraData)),
			test.StakeVersion)
		if gotHash != wantPowHash {
			t.Fatalf("test #%d: did not get expected proof of work hash -- "+
				"got: %x, want: %x", i, gotHash, wantPowHash)
		}
	}
}
</source>

===ASERT éš¾åº¦è®¡ç®—===

ASERT éš¾åº¦ç®—æ³•çš„ JSON æµ‹è¯•å‘é‡å¯åœ¨[[asert_test_vectors.json]].ä¸­æ‰¾åˆ°ã€‚

æµ‹è¯•æ•°æ®ç”±å„ç§åœºæ™¯ç»„æˆï¼Œå…¶ä¸­åŒ…æ‹¬ä¸€ç»„å‚æ•°ã€èµ·å§‹æ¡ä»¶ä»¥åŠä¸è¿™äº›èµ·å§‹æ¡ä»¶ç›¸å…³çš„ä¸€ç³»åˆ—åŒºå—é«˜åº¦å’Œæ—¶é—´æˆ³ï¼Œä»¥åŠå®ƒä»¬çš„é¢„æœŸç»“æœéš¾åº¦ä½ã€‚æµ‹è¯•æ•°æ®åœ¨é¡¶éƒ¨é™„è¿‘è¿˜æœ‰æ³¨é‡Šï¼Œæè¿°æ¯ä¸ªå­—æ®µçš„æ ¼å¼ã€‚

ä»¥ä¸‹ç¤ºä¾‹ Go ä»£ç æä¾›äº†ä¸€ä¸ªæµ‹è¯•å‡½æ•°ï¼Œç”¨äºåŠ è½½å’Œè§£ææ–‡ä»¶ã€æ‰§è¡Œæ‰€æœ‰æµ‹è¯•å¹¶éªŒè¯ç»“æœï¼š

<source lang="go">
func calcASERTDiff(startDiffBits uint32, powLimit *big.Int, targetSecsPerBlock,
	timeDelta, heightDelta, halfLife int64) uint32) {

	// Your implementation...
	return 0
}

func TestCalcASERTDiff(t *testing.T) {
	// Read and parse the reference test vectors.
	f, err := os.ReadFile("asert_test_vectors.json")
	if err != nil {
		t.Fatalf("failed to read test vectors: %v", err)
	}
	var testData struct {
		Comments []string `json:"comments"`
		Params   map[string]struct {
			PowLimit           string `json:"powLimit"`
			PowLimitBits       uint32 `json:"powLimitBits"`
			TargetSecsPerBlock int64  `json:"targetSecsPerBlock"`
			HalfLifeSecs       int64  `json:"halfLifeSecs"`
		} `json:"params"`
		Scenarios []struct {
			Desc          string `json:"description"`
			Params        string `json:"params"`
			StartDiffBits uint32 `json:"startDiffBits"`
			StartHeight   int64  `json:"startHeight"`
			StartTime     int64  `json:"startTime"`
			Tests         []struct {
				Height           uint64 `json:"height"`
				Timestamp        int64  `json:"timestamp"`
				ExpectedDiffBits uint32 `json:"expectedDiffBits"`
			} `json:"tests"`
		} `json:"scenarios"`
	}
	err = json.Unmarshal(f, &testData)
	if err != nil {
		t.Fatal(err)
	}

	for _, scenario := range testData.Scenarios {
		// Lookup the associated network parameters and parse the proof of work
		// limit hexadecimal to a uint256.
		paramsKey := scenario.Params
		params, ok := testData.Params[paramsKey]
		if !ok {
			t.Errorf("%q: bad network params key %q", scenario.Desc, paramsKey)
			continue
		}
		powLimit, ok := new(big.Int).SetString(params.PowLimit, 16)
		if !ok {
			t.Errorf("%q: malformed pow limit %q", paramsKey, params.PowLimit)
			continue
		}

		for _, test := range scenario.Tests {
			// Calculate the time and height deltas from the test data.
			heightDelta := int64(test.Height - uint64(scenario.StartHeight))
			timeDelta := test.Timestamp - scenario.StartTime

			// Ensure the calculated difficulty matches the expected result.
			gotDiff := calcASERTDiff(scenario.StartDiffBits, powLimit,
				params.TargetSecsPerBlock, timeDelta, heightDelta,
				params.HalfLifeSecs)
			if gotDiff != test.ExpectedDiffBits {
				t.Errorf("%q@height %d: did not get expected difficulty bits "+
					"-- got %08x, want %08x", scenario.Desc, test.Height,
					gotDiff, test.ExpectedDiffBits)
				continue
			}
		}
	}
}
</source>

==è‡´è°¢==

æœ¬ææ¡ˆä¸­çš„ ASERT ç®—æ³•åœ¨å¾ˆå¤§ç¨‹åº¦ä¸ŠåŸºäºä»¥ä¸‹æ¥æºçš„å·¥ä½œï¼š

* [[http://toom.im/files/da-asert.pdf|é™æ€éš¾åº¦è°ƒæ•´ï¼Œç»å¯¹é¢„å®šçš„æŒ‡æ•°ä¸Šå‡ç›®æ ‡ï¼ˆDA-ASERTï¼‰â€”â€”v2]], Mark B. Lundeberg
* [[https://arxiv.org/pdf/2006.03044.pdf|ä¸ç¨³å®šçš„ååé‡ï¼šå½“éš¾åº¦ç®—æ³•å´©æºƒæ—¶]], Dragos I. Ilie, Sam M. Werner, Iain D. Stewart å’Œ William J. Knottenbelt
* [[https://documentation.cash/protocol/forks/hf-20201115.html|BCHå‡çº§HF-20201115]]

===åˆä½œè€…===

æ„Ÿè°¢ä»¥ä¸‹äººå‘˜åœ¨å…±è¯†ä»£ç å’Œæœ¬ææ¡ˆçš„å®¡æ ¸è¿‡ç¨‹ä¸­æä¾›äº†å®è´µçš„åé¦ˆï¼ˆæŒ‰å­—æ¯é¡ºåºæ’åˆ—ï¼‰ï¼š

* David Hill ([[https://github.com/dajohi|@dajohi]])
* Jamie Holdstock ([[https://github.com/jholdstock|@jholdstock]])
* Joe Gruffins ([[https://github.com/JoeGruffins|@JoeGruffins]])
* Josh Rickmar ([[https://github.com/jrick|@jrick]])
* Matheus Degiovani ([[https://github.com/matheusd|@matheusd]])

==å‚è€ƒ==

===å†…è”å‚è€ƒæ–‡çŒ®===

<references />

===é™„åŠ å‚è€ƒèµ„æ–™===

# [[https://raw.githubusercontent.com/BLAKE3-team/BLAKE3-specs/master/blake3.pdf|BLAKE3è§„æ ¼]]
# [[https://proposals.decred.org/record/a8501bc|Politeia ææ¡ˆ - å°† PoW/PoS åŒºå—å¥–åŠ±åˆ†å‰²æ›´æ”¹ä¸º 1/89ï¼Œå¹¶å°† PoW ç®—æ³•æ›´æ”¹ä¸º BLAKE3]]

==ç‰ˆæƒ==

æœ¬æ–‡æ¡£æ ¹æ® [https://creativecommons.org/publicdomain/zero/1.0 CC0-1.0: Creative Commons CC0 1.0 Universal] è·å¾—è®¸å¯ã€‚

è¯¥ä»£ç æ ¹æ®[https://opensource.org/licenses/ISC ISC License]è·å¾—è®¸å¯ã€‚
